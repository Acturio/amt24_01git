[["index.html", "Introducción a Git BIENVENIDA Objetivo Instructor Alcances del curso Duración y evaluación del curso Recursos y dinámica de clase Asesorías", " Introducción a Git BIENVENIDA Objetivo Agregar objetivos del curso Agregar imagen de git + github Instructor ACT. ARTURO BRINGAS LinkedIn: arturo-bringas Email: act.arturo.b@ciencias.unam.mx Actuario egresado de la Facultad de Ciencias con maestría en Ciencia de Datos por el ITAM. Se especializa en modelos predictivos y de clasificación de machine learning aplicado a seguros, banca, marketing, deportes, e-commerce y movilidad. Ha sido consultor Senior Data Scientist para empresas y organizaciones como GNP, El Universal, UNAM, la Organización de las Naciones Unidas Contra la Droga y el Delito (UNODC), Comisión Nacional de los Derechos Humanos (CNDH), Sinia, Geek-end, Invesmark, entre otros. Ha contribuido en más de 30 proyectos de impacto nacional con diferentes institutos de investigación de la UNAM como el Instituto de Investigaciones Sociales, Instituto de Geografía, Instituto de Investigaciones Jurídicas, Programa Universitario de Estudios sobre la Ciudad, Fundación UNAM y Rectoría. Actualmente es Data Scientist Expert en la fábrica de inteligencia artifical en BBVA (AI Factory), es profesor de Ciencia de datos y Machine Learning en AMAT, y consultor estadístico de encuestas nacionales de investigación social realizadas por la UNAM. Adicionalmente, participa en el Laboratorio Nacional de Observación de la Tierra (LANOT) en la detección en tiempo real de contaminación del mar por sargazo a través de algoritmos de IA y percepción remota aplicados a los datos proveidos por el satélite Landsat9. Alcances del curso Al finalizar este curso, el participante será capaz de … Requisitos: Computadora con al menos 8Gb Ram Instalar Git con versión XXX o superior Instalar un IDE VSCode Temario: Duración y evaluación del curso El programa tiene una duración de XX hrs. Las clases serán impartidas los días sábado, de 9:00 am a 11:00 am Serán asignados ejercicios que el participante deberá resolver entre una semana y otra. Recursos y dinámica de clase En esta clase estaremos usando: Git VSCode da click aquí si quieres descargar Zoom Clases Pulgar arriba: Voy bien, estoy entendiendo! Pulgar abajo: Eso no quedó muy claro Mano arriba: Quiero participar/preguntar ó Ya estoy listo para iniciar One Drive Notas de clase Revisame si quieres aprender Asesorías Los profesores se encuentran en la mejor disposición de asistir las dudas de clase de todos los alumnos. El grupo de whatsapp ha sido creado para compartir información relevante al curso y exponer dudas y soluciones que puedan ser de interés de todo el grupo. Los alumnos podrán hacer uso del canal de comunicación para externar sus dudas de clase durante el tiempo que dure el curso. Los profesores se comprometen a responder en el transcurso del día las preguntas realizadas que sean relevantes con la clase. Las respuestas se realizarán de lunes a viernes en un horario de 10:00am a 8:00pm. ¡¡ AVISO !! No se atenderán dudas que tengan que ver con otros proyectos o asignaciones laborales de los estudiantes en sus respectivos ambientes de trabajo. Se invita a los estudiantes a que las dudas realizadas en clase sean relevantes a la clase y los ejemplos a resolver sean de interés para todo el alumnado. Nota: En caso de requerir consultoría especializada o particular a un tema de interés, se deberá contactar al área administrativa para solicitar la cotización correspondiente al servicio correspondiente. "],["introducción-del-curso.html", "Capítulo 1 Introducción del curso 1.1 Objetivos del Curso 1.2 ¿Cómo funciona el curso? 1.3 Instalaciones", " Capítulo 1 Introducción del curso 1.1 Objetivos del Curso En esta sección, se menciona a grandes razgos el contenido del curso en general, por lo que todos los detalles se expondrán en sus respectivas secciones; no usaremos Git hasta la sección 2. Bienvenidos a este curso introductorio de Git, en este curso nos encaminaremos al dominio de una de las herramientas más útiles para todo desarrollador. Git es un sistema de control de versiones,diseñado para manejar de todo, desde pequeños proyectos independientes hasta grandes y ambiciosos proyectos con rapidez y eficiencia. es una herramienta esencial para desarroladores de cualquier ámbito, ya que facilita la colaboración y el seguimiento de cambios en el código de manera organizada. Tiene una clara orientación al código; te permite tener a dispocisión las versiones anteriores de cada proyecto en el que trabajes con el fin de tener una “Linea del tiempo” de tu proyecto que te permita ver los cambios que se han realizado a lo largo del tiempo. Git, de manera automática (a menos que se encuentre un conflicto); Lee los archivos involucrados en el proyecto Determina que cambios hubo en cada archivo actualizado Une bloques de código de un mismo proyecto. Un conflicto es que varios desarrolladores intentan hacer cambios distintos al mismo contendo, lo que hace que git no sepa cuales cambios guardar. Existen tecnicas para evitar conflictos, estas se verán dentro del curso. El objetivo de este curso es que puedas: Administrar y organizar tu equipo de trabajo Plantear y alcanzar metas en conjunto Tener una visión general del repositorio de trabajo En este curso no se utilizarán gestores con interfáz gráfica, ya que la mayoría de las características más nuevas de git no han sido implementadas en gestores visuales, dado que este tipo de gestores son de uso más básico. Por ello priorizaremos el uso de la consola / terminal del sistema operativo (En el caso de Windows se recomienda utilizar Git Bash) pero, para mayor comodidad, se hará uso de Visual Studio Code. Consejo: Tener una librería (archivo de todos los comandos que veamos), será muy útil para repasar el contenido que vayamos viendo lo que reforzará sus conocimientos adquiridos en el curso. 1.2 ¿Cómo funciona el curso? El curso se dará en sesiones sincrónicas de aproximadamente 4 horas de duración, a través de zoom, en las que se explican los temas y se presentan ejemplos claros de cada lección para reforzar los conocimientos adquiridos en estas sesiones, contamos con: Tareas practicas Material para ejercicios y prácticas Para el curso se creará un grupo de WhatsApp en el que se encontrarán los instructores para que puedan expresar sus dudas o compartir material concerniente al curso, sobre todo fuera de las sesiones. 1.3 Instalaciones Antes de cualquier otra cosa debemos instalar tanto Git, como Visual Studio Code, para ello dejamos enlaces a las páginas oficiales de ambos programas. Enlaces: Git Visual Studio Code Respecto a la documentación, no recommendamos que la lean sin los conocimientos básicos de git, tras haber terminado el curso estarán familiarizados con el mismo lenguaje, lo que les permitirá comprender mejor el contenido de la propia documentación. "],["fundamentos-de-git.html", "Capítulo 2 Fundamentos de Git 2.1 Introducción a los fundamentos de Git 2.2 Importancia de Git 2.3 Configuración inicial de Git 2.4 Primeros comandos de Git 2.5 Primer Repositorio [Ejercicio] 2.6 Distintas maneras de agregar elementos al Stage 2.7 Repaso 2.8 Alias", " Capítulo 2 Fundamentos de Git A continuación, un par de recomendaciones para el resto del curso: Tomar nota de los comandos que se verán en el curso, así como de que hace y como funciona cada uno, de forma que ustedes mismos entiendan lo que hace un comando y en que casos se ocupa. Constantemente revisar su lista de comandos, esto para que vayan repasando y se familiaricen con los mismos, es recomendable hacerlo antes de cada sesión para tener esos conocimientos frescos. 2.1 Introducción a los fundamentos de Git Git es un sistema de control de versiones que, a diferencia de otros sistemas de control de versiones, almacena y maneja la información como un conjunto de copias instantáneas de un sistema de archivos miniatura. La mayoría de las operaciones en Git solo necesitan archivos y recursos locales para funcionar, lo que lo hace muy rápido. Git tiene tres estados principales en los que se pueden encontrar tus archivos: Confirmado: significa que los datos están almacenados de manera segura en tu base de datos local. Modificado: significa que has modificado el archivo pero todavía no lo has confirmado a tu base de datos. Preparado: significa que has marcado un archivo modificado en su versión actual para que vaya en tu próxima confirmación. Esto nos lleva a las tres secciones principales de un proyecto de Git: El directorio de Git (Git directory), el directorio de trabajo (working directory), y el área de preparación (staging area). El directorio de Git: Es donde se almacenan los metadatos y la base de datos de objetos para tu proyecto. El directorio de trabajo: Es una copia de una versión del proyecto. Estos archivos se sacan de la base de datos comprimida en el directorio de Git, y se colocan en disco para que los puedas usar o modificar. El área de preparación: Es un archivo, generalmente contenido en tu directorio de Git, que almacena información acerca de lo que va a ir en tu próxima confirmación. A veces se le denomina índice (“index”). Git está diseñado para gestionar proyectos de software y otros tipos de documentos de manera eficiente y colaborativa. Aquí están algunos conceptos fundamentales: Repositorio: Es un espacio donde Git almacena todos los archivos y carpetas que forman parte de tu proyecto. Clonar: Es hacer una copia exacta de un repositorio remoto en tu máquina local. Status: Muestra el estado actual de tu repositorio de Git, incluyendo cambios sin confirmar y archivos no rastreados. Commit: Es un registro de cambios en el repositorio. Cada commit tiene un mensaje que describe los cambios realizados. Branch (Rama): Es una versión paralela del código principal. Se utilizan para desarrollar funcionalidades nuevas sin afectar el código principal hasta que estén listas. Merge (Fusionar): Es el proceso de combinar cambios de una rama a otra. Por ejemplo, fusionar una rama de funcionalidad en la rama principal (como main o master). Push (Subir) y Pull (Bajar): Push se refiere a enviar cambios locales al repositorio remoto, mientras que Pull es obtener cambios del repositorio remoto a tu repositorio local. 2.2 Importancia de Git ¿Porqué es importante saber Git o cualquier otro sistema de control de versiones? Los sistemas de control de versiones (SCV), como lo es Git, son fundamentales en el desarrollo de software por varias razones clave: Gestión de Historial: Permiten mantener un registro detallado de todos los cambios realizados en el código y documentos del proyecto. Cada modificación se documenta con un mensaje descriptivo, lo que facilita la comprensión de la evolución del proyecto. Colaboración Eficiente: Facilitan el trabajo en equipo al permitir que varios desarrolladores trabajen simultáneamente en diferentes aspectos del proyecto. Las ramas (branches) permiten trabajar en nuevas funcionalidades sin interferir con el código principal. Reversión y Recuperación: Ofrecen la capacidad de revertir cambios no deseados o recuperar versiones anteriores del código en caso de errores o problemas inesperados. Experimentación Segura: Las ramas permiten probar nuevas ideas de forma segura antes de integrarlas en el código principal, lo que ayuda a mantener la estabilidad del proyecto. Seguimiento de Responsabilidades: Asignan responsabilidades claras al registrar quién realizó cada cambio y cuándo, lo que facilita la revisión y la resolución de problemas. Es como en un videojuego donde tienes puntos de control, en el caso de Git serían los commits, a los que puedes volver si te encuentras en un problema y debes andar por otro camino o seguir una estrategia diferente. En resumen, los SCV son esenciales para mantener la integridad, colaboración y evolución ordenada de los proyectos de software, mejorando la eficiencia y reduciendo el riesgo de errores en el desarrollo. Existen distintos modelos de SCV, a continuación explicaremos 2 de los más implementados, veremos sus características y complementaremos con una analogía. Repositorio Central Es un modelo de control de versiones donde existe un único servidor central que contiene la versión principal del proyecto. Los desarrolladores envían sus cambios directamente a este servidor central. Características: Centralizado: Todos los desarrolladores envían y reciben cambios desde el mismo lugar. Dependencia del servidor: Requiere acceso constante al servidor central para realizar operaciones clave como commits y actualizaciones. Historial único: El historial completo del proyecto reside en el servidor central. Ejemplo: Imagina que hay una Torre de los Vengadores (Repositorio Central) en Nueva York. Esta Torre es el cuartel general de los Vengadores y donde se almacenan todas las misiones y planes importantes (código fuente). Todos los Vengadores (desarrolladores) tienen que ir a esta torre para obtener las misiones y para reportar los resultados de sus tareas. Obteniendo misiones (Pulling): Cada Vengador (desarrollador) vuela a la Torre de los Vengadores (repositorio central) para obtener su misión (código actual). Cuando alguien necesita una actualización, va directamente a la Torre. Reportando misiones completadas (Pushing): Una vez que el Vengador ha completado su misión (hecho sus cambios), vuelve a la Torre para informar (hacer push) y actualizar el cuartel general con los resultados. Todos los demás Vengadores pueden ver esta actualización la próxima vez que vuelvan a la Torre. En este modelo, la Torre de los Vengadores es la única fuente de verdad y todos los Vengadores dependen de ella. Repositorio Distribuido En este modelo cada desarrollador tiene una copia completa del repositorio, incluyendo historial y ramas, en su máquina local. Los cambios se intercambian directamente entre repositorios locales o a través de uno central opcional. Características: Descentralizado: Cada desarrollador tiene su propio repositorio completo, lo que permite trabajar sin conexión a internet y facilita la colaboración. Flexibilidad: Los cambios pueden ser compartidos entre repositorios locales o a través de repositorios remotos. Ramas y experimentación: Permite a los desarrolladores trabajar en ramas independientes y experimentar sin afectar el repositorio principal hasta que estén listos. Ejemplo: Ahora, imagina que el multiverso de Marvel está en plena acción, con diferentes versiones de los Vengadores en cada universo. Cada uno de estos equipos de Vengadores (desarrolladores) tiene su propia Torre (su propio repositorio) en su universo. Misiones propias (Local Commits): En cada universo, los Vengadores tienen sus propias misiones que pueden completar de manera independiente, sin tener que volver a la Torre principal en Nueva York. Cada universo tiene su propia copia de las misiones (repositorio completo) y pueden hacer cambios sin necesidad de interactuar con otros universos. Intercambio de misiones entre universos (Push/Pull entre repositorios): A veces, los Vengadores de un universo pueden decidir compartir misiones o resultados con otro universo. Por ejemplo, los Vengadores de Tierra-616 podrían decidir que los Vengadores de Tierra-199999 necesitan saber algo que descubrieron. Entonces, envían esa misión o resultado (push) a la Torre de otro universo o piden recibir actualizaciones (pull) de ellos. Sin Torre central única: No hay una Torre central a la que todos los Vengadores tengan que ir. Cada universo es autónomo y puede compartir información con otros universos según sea necesario. La diferencia clave radica en la arquitectura y la forma en que se gestionan y comparten los cambios. Los repositorios centrales son más tradicionales y dependen de un servidor centralizado, mientras que los distribuidos ofrecen mayor flexibilidad, autonomía y capacidad de trabajo offline. Git trabaja con el sistema de repositorio distribuido lo que permite que todo el equipo trabaje libremente sin depender de que el servidor central permanezca en condiciones de trabajo. 2.3 Configuración inicial de Git Para comenzar vamos a configurar nuestro nombre de usuario, así como nuestro correo electrónico, estos van a servir para identificarnos y, más adelante, conectarnos con Github. git config --global user.name &quot;[Nombre de usuario]&quot; git config --global user.email &quot;[Direccion de correo]&quot; El correo no necesariamnete debe estar registrado en Github, sin embargo, para trabajar con esta plataforma es recomendable usar el correo con el que te registraste o vas a registrar en Github, ya que tanto el nombre como el correo sirven para identificar al usuario. Al iniciar un repositorio, Git crea una rama principal que generalmente es llamada master o main, Por diversas razones ultimamente esta segunda opción se ha vuelto la prferencia, por lo que vamos a establecer main como nombre por defecto de la rama principal: git config --global init.defaultBranch main Con este comando se establece main como nombre por defecto de la rama principal para cualquier nuevo repositorio. Si prefieres cambiar el nombre de la rama principal, o cualquier otra, puedes usar: git branch -m [actual] [nuevo] Cambia el nombre [actual] de la rama por el [nuevo] en el repositorio actual sin alterar la configuración. Para visualizar las configuraciones que tenemos en git, podemos utilizar el comando git config --global -e [user] name = Nombre de usuario email = Direccion de correo [init] defaultBranch = main Este comando abre el archivo de configuración global de Git en el editor de texto predeterminado para que puedas editarlo. 2.4 Primeros comandos de Git Para empezar vamos a abrir la terminal, en caso de Windows Git Bash, para presentar los primeros comandos. git --version git version 2.47.0 Muestra la versión instalada de Git en tu sistema. En este caso contamos con la versión 2.47.0 de Git. git --help usage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;] &lt;command&gt; [&lt;args&gt;] These are common Git commands used in various situations: start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects &#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and some concept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39; to read about a specific subcommand or concept. &lt;!-- See &#39;git help git&#39; for an overview of the system. --&gt; Muestra una lista de comandos disponibles en Git junto con una breve descripción de cada uno y cómo usarlos. git --help [nombre del comando] Muestra la documentación detallada y las opciones disponibles para el comando especificado en Git. 2.5 Primer Repositorio [Ejercicio] Con el material Demografia y en compañía de los instructores, van a crear su primer repositorio, para ello hay que acceder a la carpeta Demografia, una vez descomprimido el arcivo Demografia.zip. En este ejercicio se van a presentar los siguientes comandos: git init Inicializado repositorio Git vacío en /[path]/Demografia/.git/ Este comando inicializa un nuevo repositorio de Git en el directorio actual [Demografia], creando un subdirectorio .git con todos los archivos necesarios para el control de versiones. git status En la rama main No hay commits todavía no hay nada para confirmar (crea/copia archivos y usa &quot;git add&quot; para hacerles seguimiento) El comando muestra el estado actual del repositorio, incluyendo los cambios en el área de preparación y los archivos modificados que no están preparados para el commit. git add images Añade la carpeta images al área de preparación para ser incliudo en el próximo commit, en caso de ser un directorio se agregan tolos los archivos y subdirectorios que contiene. git add . Agrega todos los archivos nuevos y modificados del directorio actual al área de preparación para el próximo commit. git reset EDOMEX-demo.R Deshace los cambios en EDOMEX-demo.R, en este caso no hay cambios pero el archivo no se guardará, retirándolo del área de preparación sin modificar el directorio de trabajo. Si verificamos el estado del repositorio, veremos algo así: git status En la rama main No hay commits todavía Cambios a ser confirmados: (usa &quot;git rm --cached &lt;archivo&gt;...&quot; para sacar del área de stage) nuevos archivos: Demografia.Rmd nuevos archivos: Demografia.pdf nuevos archivos: DistribucionNE-2010.xlsx nuevos archivos: DistribucionNE-2020.xlsx nuevos archivos: EDOMEX2010.Rda nuevos archivos: EDOMEX2010.csv nuevos archivos: EDOMEX2010M.Rda nuevos archivos: EDOMEX2020.Rda nuevos archivos: EDOMEX2020.csv nuevos archivos: EDOMEX2020M.Rda nuevos archivos: images/indice-masculinidad.png nuevos archivos: images/piramide-EDOMEX-2010.png nuevos archivos: images/piramide-EDOMEX-2020.png Archivos sin seguimiento: (usa &quot;git add &lt;archivo&gt;...&quot; para incluirlo a lo que será confirmado) EDOMEX-demo.R git commit -m &quot;commit inicial&quot; [main (commit-raíz) 37fd5c8] commit inicial 13 files changed, 395 insertions(+) create mode 100644 Demografia.Rmd create mode 100644 Demografia.pdf create mode 100755 DistribucionNE-2010.xlsx create mode 100755 DistribucionNE-2020.xlsx create mode 100644 EDOMEX2010.Rda create mode 100755 EDOMEX2010.csv create mode 100644 EDOMEX2010M.Rda create mode 100644 EDOMEX2020.Rda create mode 100644 EDOMEX2020.csv create mode 100644 EDOMEX2020M.Rda create mode 100644 images/indice-masculinidad.png create mode 100644 images/piramide-EDOMEX-2010.png create mode 100644 images/piramide-EDOMEX-2020.png Realiza un commit con un mensaje descriptivo especificado en \"commit inicial\", guardando los cambios realizados en el repositorio de Git. Hasta esta parte del ejercicio creaste tu primer repositorio, conociste al área de preparación e hiciste tu primer commit. Quizá ahora tengas una pregunta en mente. ¿Para qué me sirve estar haciendo commit frecuetemente?. Supongamos que por un fallo se corrompieron los archivos en los que estabas trabajando, o que por error borraste algo que no debías; esta clase de sucesos ocurren con bastante frecuencia pero, con ayuda de Git, podrás recuperar tu información. git checkout -- . El comando git checkout tiene muchas funcionalidades, pero en particular git checkout -- . restaura todos los archivos en el directorio de trabajo a su estado más reciente en el repositorio (último commit), descartando los cambios no confirmados, permitiendo recuperar la información delo último commit realizado, pero esto sólo con los archivos a los que Git les da seguimiento, por lo que es una buena páctica hacer commit con cierta regularidad. git log commit e4d9d8e7b9367137765f42870a06e29d295a7434 (HEAD -&gt; main) Author: [Nombre de usuario] &lt;[Direccion de correo]&gt; Date: Mon Jul 8 21:55:45 2024 -0600 commit inicial Muestra el historial de commits del repositorio, incluyendo mensajes, autores y fechas, la clave alfanumérica que aparece al principio de cada commit es el hash con el que Git regitra ese commit, cada clave es distinta y le corresponde una única instantanea (commit). Este comando muestra mucha información que realmente entorpece la visualización, pero hay maneras de mejorar la forma en que se presenta esta información. git log --oneline e4d9d8e (HEAD -&gt; main) commit inicial Muestra una forma reducida del hash de cada commit seguido de su mensaje de identificación. Cabe aclarar que la palabra HEAD marca al último commit realizado y que (HEAD -&gt; main) indica que dicho commit se realizó en la rama main. 2.6 Distintas maneras de agregar elementos al Stage Ya sabemos que con git add podemos agregar uno por uno los elementos que deseamos al Stage (área de preparación), y que con git add . podemos agregar todos los archivos disponibles, pero imagina que modificaste muchos archivos, pero no quieres agregalos todos y hacerlo de uno en uno sería muy tardado. Puedes agregar archivos con el mismo formata ubicados en el mismo directorio utilizando: git add *.[formato] Agrega al Stage todos los archivos .[formato] que se encuentren en el directorio actual, pero no hará nada con los archivos que se encuentren en un subdirectorio. git add [subdirectorio]/*.[formato] Este comando agrega los archivos .[formato] dentro de [subdirectorio]/ al Stage. git add [subdirectorio]/ Agrega todos los archivos modificados del [subdirectorio]. Nota: Git de manera automática ignora los directorios vacíos por lo que, si no tienes cuidado, puede ignorar un fichero importante y llegar a romper tu proyecto, para evitarlo se suele agregar un archivo llamado .gitkeep a las carpetas vacías un archivo especial para que git reconozca que debe hacerles seguimiento. De esta manera puedes organizar más facilmente los elementos modificados. 2.7 Repaso Ahora un breve repaso de los comandos que hemos visto hasta ahora. git config --global user.name &quot;[Nombre de usuario]&quot; Configura el nombre de usuario global para todos los repositorios de Git en tu sistema. git config --global user.email &quot;[Direccion de correo]&quot; Configura el correo electrónico global para todos los repositorios de Git en tu sistema. git config --global init.defaultBranch main Con este comando se establece main como nombre por defecto de la rama principal para cualquier nuevo repositorio. git branch -m [actual] [nuevo] Cambia el nombre [actual] de la rama por el [nuevo]. git config --global -e Abre el archivo de configuración global de Git en tu editor de texto predeterminado para que puedas editarlo. git --version Muestra la versión instalada de Git en tu sistema git --help Muestra una lista de comandos disponibles en Git junto con una breve descripción de cada uno y cómo usarlos. git --help [nombre del comando] Muestra la documentación detallada y las opciones disponibles para el comando especificado en Git. git init Este comando inicializa un nuevo repositorio de Git en el directorio actual. git status Muestra el estado actual del repositorio, incluyendo los cambios en el área de preparación y los archivos modificados que no están preparados para el commit. git add Añade archivos al área de preparación para ser incluidos en el próximo commit. git add . Agrega todos los archivos nuevos y modificados del directorio actual al área de preparación para el próximo commit. git reset [archivo] Deshace los cambios en el archivo especificado, retirándolo del área de preparación sin modificar el directorio de trabajo. git commit -m &quot;nombre del commit&quot; Realiza un commit con un mensaje descriptivo especificado, guardando los cambios realizados en el repositorio de Git. git checkout -- . Restaura todos los archivos en el directorio de trabajo a su estado más reciente en el repositorio (último commit), descartando los cambios no confirmados. git log Muestra el historial de commits del repositorio, incluyendo mensajes, autores y fechas. git add *.[formato] Agrega al Stage todos los archivos .[formato] que se encuentren en el directorio actual. git add [subdirectorio]/*.[formato] Este comando agrega los archivos .[formato] dentro de [subdirectorio]/ al Stage. git add [subdirectorio]/ Agrega todos los archivos modificados del [subdirectorio]. 2.8 Alias Ya conocen los comandos más básicos de Git y seguro han notado que muchos muestran información que generalmente no necesitamos, la gran mayoría de comandos en Git cuentan con etiquetas que permiten mostrar la información de manera distinta a como se hace normalmente pero, como se imaginarán, mejorar la visualización de la información hace que los comandos se extiendan mucho; por ello ahora aprenderán a crear sus propios alias. Un alias de Git es un atajo personalizado que se configura para simplificar y acortar comandos de Git frecuentemente usados. Para crear tu propio alias utiliza: git config --global alias.[alias] &quot;[Comando]&quot; Establece un alias de manera que git [alias] hará lo mismo que git \"[comando]\" Así pueden crear tus propios alias para facilitarse el trabajo. Un ejemplo muy útil sería: git config --global alias.s &quot;status -s -b&quot; Veamos el cambio, la salida de status git status En la rama main Archivos sin seguimiento: (usa &quot;git add &lt;archivo&gt;...&quot; para incluirlo a lo que será confirmado) EDOMEX-demo.R no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa &quot;git add&quot; para hacerles seguimiento) La salida de s git s ## main ?? EDOMEX-demo.R Como pueden ver, el uso de alias es muy útil, sobre todo con comandos que se usan repetidamente. Por último una recomendación de alias que será muy útil en adelante: git config --global alias.lg &quot;log --graph --abbrev-commit --decorate --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --all&quot; Con este alias se mostrarán los registros de un repositorio de manera resumida y organizada, de forma que será más facil identificar la información. "],["los-cambios-en-git.html", "Capítulo 3 Los cambios en Git 3.1 Cambios en los archivos 3.2 Correción de commits", " Capítulo 3 Los cambios en Git 3.1 Cambios en los archivos Cuando acabas de editar un archivo y quieres ver con claridad las diferencias entre las “versiones”, puedes hacerlo de varias formas, como hacer copia del “original” o ir revirtiendo los cambios poco a poco, pero tener toda la información disponible hace que fácilmente se pierda de vista lo que uno busca; git puede mostrarte, de manera organizada, unicamente los cambios que hay entre las dos versiones que quieres comparar de un archivo, lo que facilita bastante distinguir los cambios efectuados. En esta ocación presentaremos un comando que nos ayudará a distinguir los cambios realizados en un archivo. git diff diff --git a/Demografia.Rmd b/Demografia.Rmd index 0d2f647..090d477 100644 --- a/Demografia.Rmd +++ b/Demografia.Rmd @@ -134,10 +134,10 @@ $p_f = p_i \\cdot e ^ {r \\cdot h}$ Donde: -- $p_f$ es la población final -- $p_i$ es la población inicial -- $r$ es la tasa de crecimiento -- $h$ es el tiempo de crecimiento +* $p_f$ es la población final +* $p_i$ es la población inicial +* $r$ es la tasa de crecimiento +* $h$ es el tiempo de crecimiento Muestra las diferencias no confirmadas entre el directorio de trabajo y el último commit realizado. En la salida podemos notar que hay líneas que comienzan con + y -, estos cimbolos nos indican los cambios que presenta el archivo en el que se está trabajando respecto al último registro realizado. +[contenido] Indica que se agregó [contenido] al archivo en cuestión, mientras que -[contenido] Indica que [contenido] fue removido delarchivo, preo solo muestra cambios en archivos que ya tienen seguimiento y no reconoce los cambios que se encuentran en el stage. Las líneas que no cuentan con estos marcadores no han sido modificadas. git diff --staged diff --git a/Demografia.Rmd b/Demografia.Rmd index 0d2f647..090d477 100644 --- a/Demografia.Rmd +++ b/Demografia.Rmd @@ -134,10 +134,10 @@ $p_f = p_i \\cdot e ^ {r \\cdot h}$ Donde: -- $p_f$ es la población final -- $p_i$ es la población inicial -- $r$ es la tasa de crecimiento -- $h$ es el tiempo de crecimiento +* $p_f$ es la población final +* $p_i$ es la población inicial +* $r$ es la tasa de crecimiento +* $h$ es el tiempo de crecimiento Muestra las diferencias presentes en los elementos que se encuentran en el área de preparación de la misma manera que git diff. 3.2 Correción de commits En ocaciones, por algún descuido, hacemos un commit con un mensaje incompleto, mal escrito o simplemente distinto a lo que buscamos presentar, pero no hay de que alarmarse, este mensaje se puede corregir de manera sencilla. git commit --amend -m &quot;[correccion]&quot; [main 9d520f3] [correccion] Date: Thu Jul 11 18:21:25 2024 -0600 1 file changed, 5 insertions(+) Este comando permite cambiar el mensaje del último commit registrado por [correccion]. Tambien ocurre que hicimos una confirmación que puede considererse incompleta, aunque sencillamente podrías hacer otro commit con los cambios restantes, Git ofrece la opción de restaurar el commit deseado para continuar trabajando sobre él. git reset --soft HEAD^ Deshace el último commit, manteniendo los cambios en el área de preparación. Puedes sustituir HEAD^ por el hash correspondiente al último commit, incluso puedes hacerlo con cualquier otro commit, pero es más simple dejarlo así. "],["repositorio-nuevo.html", "Capítulo 4 Repositorio nuevo 4.1 Preparación de repositorio 4.2 Viajes en los registros 4.3 Cambiar de nombre y eliminar archivos 4.4 Ignorar archivos no deseados 4.5 Resumen", " Capítulo 4 Repositorio nuevo En este capítulo vamos a simular distintos escenarios en los que nos podemos encontrar al desarrollar un proyecto; Vamos a trabajar ahora con la carpeta material-numeros, que se proporcionará por los instructores, y pondremos en practica los conocimientos adquiridos hasta ahora a la vez que profundizamos en las distintas opciones que nos proporciona la herramienta Git. Con ese propósito vamos a seguir una narrativa en la cual nos encontramos desarrollando un proyecto llamado números. 4.1 Preparación de repositorio Primero vamos a preparar el repositorio y haremos que Git rastreé los cambios relalizados en el proyecto. Desde la terminal, nos colocamos en la ubicación de la carpeta material-numeros/ e inicializamos un repositorio de Git con git init Inicializado repositorio Git vacío en [path]/material-marvel/.git/ Uno por uno, vamos a registrar los archivos: README.md, descripciones.md, origenes.md, debilidades.md y el directorio misiones/ (haciendo commit); recuerde que debes llevarlos al Satage con git add [elemento] para luego poder registrarlos con un mensaje a traves de git commit -m &quot;[elemento] agregado&quot; [main (commit-raíz) 95403cb] Readme.md agregado 1 file changed, 17 insertions(+) create mode 100644 README.md Vamos a cambiar el mensaje de registro que hicimos al guardar el directorio misiones/, para ello usaremos git commit --amend misiones/ agregado # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Fecha: Wed Jan 15 16:29:04 2025 -0600 # # En la rama main # Cambios a ser confirmados: # nuevos archivos: misiones/black_widow.md # nuevos archivos: misiones/hulk.md # nuevos archivos: misiones/iron_man.md # nuevos archivos: misiones/spider_man.md # nuevos archivos: misiones/thor.md # Este comando abrirá el editor de texto por defecto de cada equipo para mostrar un archivo de registro, el cual vamos a editar de la siguiente manera: La primera línea, donde se encuentra escrito misiones/ agregado, cambiaremos ese mensaje por: misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. Y guardemos los cambios en el archivo de registro. Con los registros realizados hasta ahora, tomando en cuenta que se suguió la recomendación de alias presentada al final del Capítulo 2, usando git lg deberiamos tener una salida como la que sigue git lg * 0e01379 - (hace 6 minutos) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] (HEAD -&gt; main) * 471d1b7 - (hace 7 minutos) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 8 minutos) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 8 minutos) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 9 minutos) Readme.md agregado - [Nombre de usuario]% 4.2 Viajes en los registros Ya que Git rastrea todos los elementos involucrados en el proyecto empezamos a hacer cambios para, posteriormente, realizar los viajes en los commits realizados. Empezando con la edición de archivos, en el archivo README.md se encontrarán con una lista de clases de números, a la que le agregaremos, al final, el siguiente elemento: - [doctor strange](/misiones/doctor_strange.md) Luego, al archivo descripciones.md le vamos a agregar: ## Doctor Strange - **Nombre real:** Stephen Vincent Strange. - **Descripción:** Un neurocirujano convertido en el Hechicero Supremo, protector de la Tierra. Después, en el archivo origenes.md añadimos: ## Doctor Strange - Tras un accidente automovilístico que dañó gravemente sus manos, aprendió las artes místicas y se convirtió en el Hechicero Supremo. Por último, en el archivo debilidades.md agregamos: ## Doctor Strange - Dependencia de artefactos mágicos. - Relaciones humanas complejas. Tras los cambios anteriormente realizados, haremos una verificación. git s ## main M README.md M debilidades.md M descripciones.md M origenes.md ?? misiones/doctor_strange.md Prara darle seguimiento, agregamos al área de preparación el archivo misiones/doctor_strange.md git add misiones/doctor_strange.md Así, de ahora en adelante, git le dará seguimiento a las misiones de Doctor Strange. Ahora haremos un nuevo commit con el siguiente comando. git commit -am &quot;Se une Deoctor Strange&quot; [main 9d082cd] Se une Deoctor Strange 5 files changed, 33 insertions(+) create mode 100644 misiones/doctor_strange.md Comenzaremos con los viajes en el tiempo, primero veamos nuestra línea del tiempo con git lg * 9d082cd - (hace 50 segundos) Se une Deoctor Strange - [Nombre de usuario] (HEAD -&gt; main) * 0e01379 - (hace 44 minutos) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] * 471d1b7 - (hace 44 minutos) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 45 minutos) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 46 minutos) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 47 minutos) Readme.md agregado - [Nombre de usuario]% Vemos todos los registros que hemos hecho hasta ahora, pero supongamos que a la vez se unió Daredevil por lo que quermeos agregarlo también, pero en lugar de hacer un nuevo commit, buscamos que sean agregados a la vez. Para ello, vamos a usar el comando git reset --soft, pero recordemos que este nos permite darle la entrade HEAD^ o en su lugar el hash de registro del commit al que nos vamos a mover; esta vez usaremos esta segunda forma, en este caso el paámetro que usaremos es el penúltimo [hash] que mostró el comando git lg, por lo que emplearemos git reset --soft [hash] Ahora podemos agregar los números complejos para registrarlos junto a los imaginarios, lo que haremos como anteriormente: Creamos el archivo misiones/daredevil.md y le agregamos: # Misiones de Daredevil 1. **Desmantelar la operación de Kingpin en Hell´s Kitchen** - **Descripción:** Investigar y recolectar evidencia de las actividades criminales de Kingpin para entregarlas a las autoridades. - **Prioridad:** Alta - **Fecha límite:** 2025-02-15 2. **Proteger a un testigo clave** - **Descripción:** Asegurar la seguridad de un testigo que tiene información vital para un juicio contra una organización criminal. - **Prioridad:** Alta - **Fecha límite:** 2025-02-05 3. **Desmantelar un laboratorio de drogas** - **Descripción:** Localizar y destruir un laboratorio oculto utilizado por una pandilla para fabricar y distribuir drogas en Hell´s Kitchen. - **Prioridad:** Media - **Fecha límite:** 2025-01-30 Al archivo README.md le agregaremos: - [daredevil](/misiones/daredevil.md) Luego, al archivo descripciones.md le vamos a agregar: ##Daredevil - **Nombre real:** Matthew Michael Murdock. - **Descripción:** Un abogado ciego que combate el crimen en Hell´s Kitchen como Daredevil, usando sus sentidos sobrehumanos y habilidades de combate excepcionales. Después, en el archivo origenes.md añadimos: ## Daredevil - Tras un accidente con químicos tóxicos, perdió la vista pero desarrolló sentidos sobrehumanos. Por último, en el archivo debilidades agregamos: ## Daredevil - Dependencia de los sentidos aumentados. - Falta de protección física. Haciendo una verificación de los cambios. git s ## main MM README.md MM debilidades.md MM descripciones.md A misiones/doctor_strange.md MM origenes.md ?? misiones/daredevil.md Veremos que hay algunos cambios que ya se agregaron al Satge, los referentes a la entrada de números imaginarios, pero también encontramos cambios en el directorio de trabajo, los que se acaban de añadir, junto a la adición de los archivos misiones/doctor_strange.md y misiones/daredevil.md. Le daremos seguimiento a las misiones de Daredevil: git add misiones/daredevil.md Comprovamos que no quede nada mos agregar al stage. git s ## main MM README.md MM debilidades.md MM descripciones.md A misiones/daredevil.md A misiones/doctor_strange.md MM origenes.md Ahora haremos un nuevo commit con el siguiente comando. git commit -am &quot;se unen Doctor Strange y Daredevil&quot; [main 75009c8] se unen Doctor Strange y Daredevil 6 files changed, 66 insertions(+) create mode 100644 misiones/daredevil.md create mode 100644 misiones/doctor_strange.md Con esto hemos cambiado el registro que teníamos por uno más completo, en el cuál agregamos tanto a Doctor Strange como a Daredevil. Veamos como se reflejan estos cambios en los registros: git lg * 75009c8 - (hace 46 segundos) se unen Doctor Strange y Daredevil - [Nombre de usuario] (HEAD -&gt; main) * 0e01379 - (hace 1 hora) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] * 471d1b7 - (hace 1 hora) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 1 hora) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 1 hora) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 1 hora) Readme.md agregado - [Nombre de usuario]% Luego de todo esto notamos que algo anda mal con los registros y que el último punto estable fue tras agregar debilidades.md por lo que vamos a copiar su [hash] de registro y esta vez usaremos: git reset --mixed [hash] Cambios fuera del área de stage tras el reset: M README.md M debilidades.md M descripciones.md M origenes.md Lo que nos regresará al punto que marcamos pero esta vez con los cambios realizados fuera del Stage, así mantenemos los cambios en el directorio de trabajo. Aquí podemos ver el el estado del repositorio. git s ## main M README.md M debilidades.md M descripciones.md M origenes.md ?? misiones/ También veamos como quedan los registros del repositorio. git lg * 471d1b7 - (hace 5 horas) debilidades.md agregado - [Nombre de usuario] (HEAD -&gt; main) * f0dddfd - (hace 5 horas) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 5 horas) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 5 horas) Readme.md agregado - [Nombre de usuario]% Como los cambios realizados después de este punto realmente no van a servirnos, haremos un reset, al mismo commit en el que nos ubicamos, pero de una manera distinta. git resset --hard [hash] HEAD está ahora en 471d1b7 debilidades.md agregado Esta vez el repositorio queda tal cual como Git lo registró y los cambios realizados tras este commit han sido removidos. Continuamos regresando en el tiempo a los commits donde se agregaron origenes.md y una vez más a donde añadimos descripciones.md, ya que es en este punto donde parece que se originan los problemas que presenta el registro. Llegados a este punto resulta que no había nada malo en el registro y hay que volver al punto en el que estábamos originalmente para recuperar toda nustra línea del tiempo; puede parecer imposible ya que eliminamos los registros que ya teníamos y tendremos que hacer cada cambio de nuevo pero Git mantiene un historial con los cambios hechos en los propios registros lo que permite recuperar esa información que se podría considerar perdida. Notemos que al acceder al historial de commits no podemos ver mas allá del segundo. git lg * d8a9a76 - (hace 5 horas) descripciones.md agregado - [Nombre de usuario] (HEAD -&gt; main) * 95403cb - (hace 5 horas) Readme.md agregado - [Nombre de usuario]% Pero Git tiene otro comando para acceder a los registros, uno que rastrea cambios de los propios registros y los movimientos en ellos. git reflog d8a9a76 (HEAD -&gt; main) HEAD@{0}: reset: moving to d8a9a76 f0dddfd HEAD@{1}: reset: moving to f0dddfd 471d1b7 HEAD@{2}: reset: moving to 471d1b7 471d1b7 HEAD@{3}: reset: moving to 471d1b7 75009c8 HEAD@{4}: commit: se unen Doctor Strange y Daredevil 0e01379 HEAD@{5}: reset: moving to 0e01379 9d082cd HEAD@{6}: reset: moving to 9d082cd 9d082cd HEAD@{7}: commit: Se une Deoctor Strange 0e01379 HEAD@{8}: commit (amend): misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. da953ea HEAD@{9}: commit (amend): misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. e91c9e8 HEAD@{10}: commit: misiones/ agregado 471d1b7 HEAD@{11}: commit: debilidades.md agregado f0dddfd HEAD@{12}: commit: oringenes.md agregado d8a9a76 (HEAD -&gt; main) HEAD@{13}: commit: descripciones.md agregado 95403cb HEAD@{14}: commit (initial): Readme.md agregado Muestra un historial de los movimientos y cambios de referencia en el repositorio. En la primer columna se nos muestran los hash correspondientes a cada commit registrado por Git. Vamos a buscar el [hash] correspondiente al commt que debemos recuperar, registrado con el mensaje se unen Doctor Strange y Daredevil, luego utilizamos: git reset --hard [hash] Para recuperar toda la linea de registro hasta ahora, lo que podemos verificar con: git lg * 75009c8 - (hace 17 minutos) se unen Doctor Strange y Daredevil - [Nombre de usuario] (HEAD -&gt; main) * 0e01379 - (hace 5 horas) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] * 471d1b7 - (hace 5 horas) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 5 horas) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 5 horas) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 5 horas) Readme.md agregado - [Nombre de usuario]% 4.3 Cambiar de nombre y eliminar archivos En el desarrollo es muy recurrente la necesidad de cambiarle el nombre a algunos archivos así como eliminarlos por distintas causas, esta vez aprenderemos a hacerlo de manera que Git se mantenga al tando de estos cambios, tanto si fueron realizados mediante Git o fuera del mismo. 4.3.1 Mediante Git Empezamos con la creación de un nuevo archivo de nombre: contactos.md Al cual le vamos a agregar la siguiente entrada: # Lista de Contactos de Emergencia ## Iron Man - **Nombre:** Pepper Potts - **Relación:** CEO de Stark Industries y pareja de Tony Stark - **Contacto:** pepper.potts@starkindustries.com | +1-555-123-4567 ## Thor - **Nombre:** Jane Foster - **Relación:** Astrofísica y expareja sentimental de Thor - **Contacto:** jane.foster@astrophysicsuniv.edu | +1-555-234-5678 ## Hulk - **Nombre:** Betty Ross - **Relación:** Bióloga celular y expareja de Bruce Banner - **Contacto:** bross@researchinstitute.com | +1-555-345-6789 ## Black Widow - **Nombre:** Yelena Belova - **Relación:** Hermana adoptiva y compañera en misiones - **Contacto:** yelena.b@redroomlegacy.org | +1-555-456-7890 ## Spider-Man - **Nombre:** Aunt May - **Relación:** Tía y figura materna de Peter Parker - **Contacto:** may.parker@nyccommunitycenter.org | +1-555-567-8901 ## Doctor Strange - **Nombre:** Wong - **Relación:** Bibliotecario y compañero Hechicero Supremo adjunto - **Contacto:** wong@sorcerersanctum.com | +1-555-678-9012 ## Daredevil - **Nombre:** Foggy Nelson - **Relación:** Mejor amigo y socio legal de Matt Murdock - **Contacto:** foggy.nelson@nelsonandmurdock.com | +1-555-789-0123 Agregamos este archivo al area de preparación git add contactos.md Hacemos un commit git commit -m &quot;contactos de emergencia agregados&quot; [main 3d9bd78] contactos de emergencia agregados 1 file changed, 43 insertions(+) create mode 100644 contactos.md Notamos que contactos es un nombre impreciso para la lista, por lo que cambiamos el nombre del archivo: git mv contactos.md contactos-emergencia.md Viemdo el estado del repositorio git s ## main R contactos.md -&gt; contactos-emergencia.md La R indica que el archivo fue renombrado. Ahora hacemos un nuevo commit del archivo renombrado git commit -m &quot;contactos.md renombrado&quot; [main d811152] contactos.md renombrado 1 file changed, 0 insertions(+), 0 deletions(-) rename contactos.md =&gt; contactos-emergencia.md (100%) Veamos el historial de registros git lg * d811152 - (hace 17 segundos) contactos.md renombrado - [Nombre de usuario] (HEAD -&gt; main) * 3d9bd78 - (hace 5 minutos) contactos de emergencia agregados - [Nombre de usuario] * 75009c8 - (hace 30 minutos) se unen Doctor Strange y Daredevil - [Nombre de usuario] * 0e01379 - (hace 5 horas) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] * 471d1b7 - (hace 5 horas) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 5 horas) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 5 horas) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 5 horas) Readme.md agregado - [Nombre de usuario]% Dado que es peligroso tener una lista de las personas más cercanas a nuestros héroes, se toma la decisión de eliminal dicha lista. git rm contactos-emergencia.md rm &#39;contactos-emergencia.md&#39; 4.3.2 Fuera de Git Esta es la manera más común de eliminar y renombrar archivos. Para no repetir los pasos anteriores, ahora vamos a trabajar con el subdirectorio misiones en el que encontramos misiones asignadas a cada héroe, resulta que Spider-Man ha terminado sus misione, por lo que cambiaremos el nombre de su archivo por: spider_man-Completados.md Este cambio, al hacer un git s / git status, a diferencia de la vez anterior aparecerá de una forma peculiar git s ## main D misiones/spider_man.md ?? misiones/spider_man-Completados.md Parece que Git no reconoce lo que hicimos como un renombramiento del archivo, sio que hemos eliminado spider_man.md y se ha creado un nuevo archivo, que aún no tiene seguimieto, llamado spider_man-Completados.md. No hay porque alarmarse con esto, utilizando git add . Git, al ver que el contenido de los archivos es idéntico, cambiará el tipo de registro a “renombrado” y podemos verificarlo usando git s ## HEAD (sin rama) R misiones/spider_man.md -&gt; misiones/spider_man-Completados.md En este caso la R indica que Git ha registrado el cambio como renombramiento, casi siempre funciona así, si en algún caso Git no registra este cmbio como “renombrado” hay que volver un paso atras, empleando git restore --staged y hacer este renombramiento mediante Git. Ahora, queda hacer el commit git commit -m &quot;misiones de Spider-Man completadas&quot; [main fd86e2e] misiones de Spider-Man completadas 1 file changed, 0 insertions(+), 0 deletions(-) rename misiones/{spider_man.md =&gt; spider_man-Completados.md} (100%) viendo como queda el registro git lg * fd86e2e - (hace 35 segundos) misiones de Spider-Man completadas - [Nombre de usuario] (HEAD -&gt; main) * 2e25e59 - (hace 3 minutos) contactos-emergencia.md eliminado - [Nombre de usuario] * d811152 - (hace 28 minutos) contactos.md renombrado - [Nombre de usuario] * 3d9bd78 - (hace 33 minutos) contactos de emergencia agregados - [Nombre de usuario] * 75009c8 - (hace 58 minutos) se unen Doctor Strange y Daredevil - [Nombre de usuario] * 0e01379 - (hace 6 horas) misiones/ agregado -&gt; misiones de los heroes: iron man, thor, hulk, black widow y spider man. - [Nombre de usuario] * 471d1b7 - (hace 6 horas) debilidades.md agregado - [Nombre de usuario] * f0dddfd - (hace 6 horas) oringenes.md agregado - [Nombre de usuario] * d8a9a76 - (hace 6 horas) descripciones.md agregado - [Nombre de usuario] * 95403cb - (hace 6 horas) Readme.md agregado - [Nombre de usuario]% como las misiones del archivo spider_man-Completados.md ya no se encuentran activas, se elimina tal archivo, despues de hacer el registro crearemos un nuevo archivo de asignaciones para Spider-Man. git lg ## main D misiones/ Veamos que Git ha registrado lo que hicimos como una eliminación del archivo spider_man-Completados.md, continuamos creando un archivo limpio de asignaciones para Spider-Man y agregando los cambios al Stage git add . y hacemos el correspondiente commit git commit -m &quot;sin saignaciones para Spider-Man&quot; [main 7540e1a] sin saignaciones para Spider-Man 2 files changed, 1 insertion(+), 18 deletions(-) delete mode 100644 misiones/spider_man-Completados.md create mode 100644 misiones/spider_man.md Así es como se eliminan y renombran archivos tanto mediante como fuera de Git. 4.4 Ignorar archivos no deseados En muchas ocaciones, dentro del proceso de desarrollo, tenemos archivos e incluso directorios a los que no nos interesa darles seguimiento; vamos a crear unos cuantos archivos y directorios de ejemplo con el objetivo de hacer que git ignore estos elementos y no regstre los cambios pesentes en ellos. Vamos a crear los siguientes directorios: dist node_modules Dentro de node_modules vamos a crear el directorio vue Ahora crearemos los archivos: server.log Aquí vamos a meter como entrada, arbitrariamente, los diguientes logs 012038239123: Exploto el equipo... 012038239123: Exploto el equipo... 012038239123: Exploto el equipo... 012038239123: Exploto el equipo... 012038239123: Exploto el equipo... 012038239123: Exploto el equipo... dentro de dist creamos index.html Que estará vacío. Por último dentro de vue, subdirectorio de node_modules creamos app.module.ts react.jsx vue.vue Estos archivos y directorios no necesitan tener sentido, y no lo tienen en este contexto pero son ejemplos de directorios o archivos comunes en proyectos que no requieren un seguimiento de los cambios presentes en ellos por diversas razones, están aqui simplemente para aprender a hacer que gir ignore los elementos que no nesesitamos que tengan ub rastreo. Veamos primero el estado del repositorio git s ## main ?? dist/ ?? node_modules/ ?? server.log 4.4.1 Archivo .gitignore Vamos a presentar el archivo .gitignore, que nos premitirá enlistar archivos y directorios que Git va a ignorar, muy útil para facilitar esta tarea. Veamos como funciona. Vamos a crear el archivo .gitignore y en este vamos a agregar la siguiente entrada: dist/ node_modules/ server.log Una vez creado el archivo, al revisar el estado del repositorio veremos que tenemos una respuesta muy distinta a la última que tuvimos git s ## main ?? .gitignore Ahora no aparecen lo elementos creados anteriormente y simplemente nos encontramos con el archivo .gitignore al que si es necesario darle seguimiento por lo que haremos su correspondiente registro. git add .gitignore git commit -m &quot;.gitignore agregado&quot; [main 09054e2] .gitignore agregado 1 file changed, 4 insertions(+) create mode 100644 .gitignore Ahora, para ver un poco de la sintaxis dentro de .gitignore vamos a crear un par de nuevos archivos a los que no se les va a dar seguimiento: application.log system.log Como no queremos que se les de seguimiento a estos archivos, hay que agregarlo al .gitignore, pero esta vez en vez de agregarlos uno por unlo cambiaremos la línea server.log por *.log de forma que el contenideo de .gitignore quedaría así: dist/ node_modules/ *.log Con este cambio le decimos a git que ignore a todos los archivos con extension log sin extender el contenido del archivo .gitignore veamos como percibe estos cambios Git: git s ## main M .gitignore Notemos que, aunque creamos dos archivos nuevos, Git solamente rastreó el cambio realizado en el archivo .gitignore. Vamos hacer un commit sobre estos cambios. git commit -am &quot;.gitignore actualizado (extension .log)&quot; [main 6cbd0da] .gitignore actualizado (extension .log) 1 file changed, 1 insertion(+), 1 deletion(-) Ahora vamos a crear un par de archivos nuevos con la extensión .log para ver como afecta al registro del repositorio; esta vez crearemos los archivos: error.log access.log Y para continuar empleamos: git s ## main Podemos notar que esta vez no se ha registrado ningún cambio realizado en el repositorio, ya que Git ignora cualquier cambio realizado a archivos con extensión .log, esto incluye la cración de nuevos archivos con dicha exensión. 4.5 Resumen Creamos un repositorio y lo preparamos para que Git haga un rastreo de los cambios presentes en sus elementos. Viajamos en los registros realizados anteriormente, hicimos algunos cambios y recuperamos todo el avance que se tenía en un principio. Aprendimos a renombrar y eliminar archivos y directorios de manera que Git pueda rastrear estos cambios de la manera adecuada. Hicimos que Git ignorara archivos a los que no nos interesa darles seguimiento. "],["ramas.html", "Capítulo 5 Ramas 5.1 Merge: Fast-forward 5.2 Merge: Unión automática 5.3 Merge: Uniones con conflictos", " Capítulo 5 Ramas En esta seccion aprenderemos a emplear las Ramas: crear, movernos entre ramas, unir ramas, entre otras funcionalidades. Primero hay que saber lo que es una rama en Git. Rama (Branch): Una rama en Git es una versión paralela del proyecto, permitiendo trabajar en desarrollo o características sin afectar la rama principal. Podemos ver a las ramas como lineas donde la rama main/master es la linea central, mientras que las ramas que se desprenden de esta avanzan de forma paraalela a la principal, lo que permite tomar caminos distintos sin alterar la historia principal. Retomando el ejemplo de un videojuego, podemos considerar a las ramas como las misiones secundarias que no alteran la historia principal pero que pueden ayudar a mejorar a nuestro personaje para que al volver a la historia principal contemos con más herramientas y experiencia de la que tendríamos solo siguiendo la historia central; el uso de las ramas en Git nos permite tomar caminos distintos sin alterar la linea central, lo que permite experimentar con nuevas implementaciones con la seguridad de poder volver a la rama principal que no ha sido alterada por los cambios realizados. Como parte del uso de las ramas, contamos con la posibiliad de tomar los cambios realizados en una rama y llevarlos a la rama principal, por ejemplo en caso de haber terminado una implmentación, podemos llevar todo ese trabajo a la rama main/master para incluir dicha implementación, esto se a través de merge. Merge: Un merge en Git es el proceso de combinar cambios de diferentes ramas en una sola rama. Este proceso se puede realizar de distintas maneras: Fast-forward: Un fast-forward en Git es una fusión en la que la rama de destino avanza directamente al nuevo commit sin crear un commit de fusión. Unión automática (Automatic merge): Una unión automática en Git es cuando Git fusiona automáticamente cambios de diferentes ramas sin conflictos manuales. Unión manual (Manual merge): Una unión manual en Git ocurre cuando se requieren resoluciones de conflictos por parte del usuario durante el proceso de fusión entre ramas. Es evidente que las el uso de las ramas es muy útil en el desarrollo de cualquier proyecto, pues nos permite hacer nuevas implementaciones y/o cambios en el código sin afectar la rama principal del repositorio. 5.1 Merge: Fast-forward Seguiremos trabajando con el material material-numerosasi que nos colocaremos desde la terminal en la ubicacion del material y seguiremos las siguientes instrucciones: Para listar las ramas que tenemos en el repositorio emplearemos: git branch * main Ahora solo contamos con la rama principal, por lo que crearemos una nueva rama, lo que vamos a implementar ahora es un conjunto números distinto a los que ya tenemos por lo que crearemos una rama llamade numeros-2, esto lo haremos empleando: gir branch numeros-2 Si volvemos a listar las ramas, encontraremos esta nueva rama que acabamos de crear: git branch * main numeros-2 Aquí podemos notar que Git nos indica la rama en la que nos encontramos a través de un asterisco * que precede al nombre de la rama sobre la que nos ubicamos, en este caso la rama main Como no queremos afectar a la rama main, vamos a cambiar a la rama que acabamos de crear: git checkout numeros-2 Cambiado a rama &#39;numeros-2&#39; Ahora, si listamos los cambios de nuestro repositorio, notaremos algo interesante: git lg * 62b4657 - (hace 8 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] (HEAD -&gt; numeros-2, main) * ae676b5 - (hace 10 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 12 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 15 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 16 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 17 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 22 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 2 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 3 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 3 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 3 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 3 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 3 horas) README.md agregado - [Nombre de usuario] Además de aparecer los nuevos commits que realizamos, podemos notar que al final de la primer línea, tenemos (HEAD -&gt; numeros-2, main), lo que nos indica que el último commit registrado por las ramas main y numeros-2 es el mimo, es decir que ambas estan en el mismo punto del repositorio, tambien podemos notar que no ha cambiado nada en los archivos o directorios. Procediendo a hacer modificaciones en el repositorio. Vamos a crear un archivo de nombre: numeros-2.md Al que le agregaremos la siguiente entrada: # Conjuntos de números alternos * Primos * Perfectos * Trascendentales * Algebraicos Agregamos al Stage y hacemos un commit git add numeros-2.md git commit -m &quot;numeros-2.md agregado&quot; [numeros-2 34238c5] numeros-2.md agregado 1 file changed, 7 insertions(+) create mode 100644 numeros-2.md Listamos los registros: git lg * 34238c5 - (hace 73 segundos) numeros-2.md agregado - [Nombre de usuario] (HEAD -&gt; numeros-2) * 62b4657 - (hace 10 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] (main) * ae676b5 - (hace 12 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 14 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 17 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 18 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 19 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 24 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 2 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 3 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 3 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 3 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 3 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 3 horas) README.md agregado - [Nombre de usuario] Podemos notar que la rama main se queda un commit por debajo de numeros-2, que ahora es el HEAD, esto porque los cambios que registramos solo afectan a la rama actual numeros-2. Agregaremos tambien las características de los números que acabamos de añadir: Creamos un archivo de nombre: caracteristicas-2.md Al que le agegaremos la siguiente entrada: # Características de los números alternos * Números naturales mayores que 1 que solo tienen dos divisores positivos: 1 y ellos mismos. * Números naturales que son iguales a la suma de sus divisores propios positivos (excluyendo el propio número). * Números reales que no son soluciones de ninguna ecuación algebraica con coeficientes racionales. * Números que son soluciones de alguna ecuación algebraica con coeficientes enteros. Agregamos al Stage y hacemos un commit git add numeros-2.md git commit -m &quot;caracteristicas-2.md agregado&quot; [numeros-2 01e1562] caracteristicas-2.md agregado 1 file changed, 7 insertions(+) create mode 100644 caracteristicas-2.md Listamos los registros: git lg * 01e1562 - (hace 25 segundos) caracteristicas-2.md agregado - [Nombre de usuario] (HEAD -&gt; numeros-2) * 34238c5 - (hace 73 segundos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 13 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] (main) * ae676b5 - (hace 15 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 17 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 20 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 21 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 22 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 27 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 2 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 3 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 3 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 3 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 3 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 3 horas) README.md agregado - [Nombre de usuario] Ahora tenemos la rama numeros-2 dos commits por delante de main. Lo que haremos a continuación es llevar estos cambios a la rama main. Nos colocamos en la rama a donde llevaremos los cambios, en este caso main: git checkout main Cambiado a rama &#39;main&#39; Notemos que los archivos y carpetas que creamos en la rama numeros-2 han desaparecido, esto es porque no hemos alterado la rama main. hacemos un merge de la rama numeros-2 a la rama main: git merge numeros-2 Actualizando 62b4657..01e1562 Fast-forward caracteristicas-2.md | 7 +++++++ numeros-2.md | 7 +++++++ 2 files changed, 14 insertions(+) create mode 100644 caracteristicas-2.md create mode 100644 numeros-2.md En esta salida podemos ver varias cosas: Se agregaron 2 entradas: caracteristicas-2.md y numeros-2.md Nos marca que acabamos de realizar un Fast-forward Este es el caso más idealpued en la rama main no se hicieron cambios antes de la union con la rama numerso-2. Si revisamos los registros: git lg * 01e1562 - (hace 4 minuto) caracteristicas-2.md agregado - [Nombre de usuario] (HEAD -&gt; main, numeros-2) * 34238c5 - (hace 5 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 19 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 21 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 23 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 26 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 27 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 28 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 30 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 2 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 3 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 3 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 3 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 3 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 3 horas) README.md agregado - [Nombre de usuario] Vemos que la ramam main y la rama numeros-2 se encuentran en el mismo commit, lo que significa que ambas estan en el mismo punto o que estan actualizadas. Como ya no vamos a trabajar en la rama numeros-2, la eliminaremos pues ya no tiene razón de existir, ya ha sido aprovechada. Para eliminar la rama numeros-2 emplearemos: git branch -d numeros-2 Eliminada la rama numeros-2 (era 01e1562). En caso de que al hacer merge no hayamos unido el último commit de la rama numeros-2, puede salirnos un error, ya que hay commits sin mezclar; en este caso podemos forzar la acción de eliminar la rama, si es que así lo deseamos, con: git branch -d numeros-2 -f 5.2 Merge: Unión automática Continuamos trabajando con el material material-numerosasi que nos colocaremos desde la terminal en la ubicacion del material y seguiremos las siguientes instrucciones: Para crear una rama nueva y a la vez movernos a ella, emplearemos: git checkout -b numeros-3 Cambiado a nueva rama &#39;numeros-3&#39; Comprobamos que nos encontramos en la nueva rama numeros-3 git branch main * numeros-3 Agregamos más elementos a numeros-2.md: * Abundantes 4.Hacemos el commit correspondiente: git commit -am &quot;numeros-2.md modificado (numeros abundantes agregados)&quot; [numeros-3 5886d1b] numeros-2.md modificado (numeros abundantes agregados) 1 file changed, 1 insertion(+) Agregamos la correspondiente caracteristica del elemento añadido en caracteristicas-2.md: * Números naturales cuya suma de divisores propios es mayor que el número mismo. Hacemos el commit correspondiente: git commit -am &quot;caractelisticas-2.md modificado (numeros abundantes agregados)&quot; [numeros-3 e26e013] caracteristicas-2 modificado (numeros abundantes agregados) 1 file changed, 1 insertion(+) Por alguna razón externa debes retirar los numeros imaginarios y complejos en el proyecto. Para hacerlo primero hay que colocarnos en la rama main: git checkout main Cambiado a rama &#39;main&#39; Una vez nos colocamos en la rama main, elominamos todo rastro de los numeros imaginarios y complejos. Luego hacemos el registro de los cambios realizados git commit -am &quot;se retiran los numeros imaginarios y complejos&quot; [main 9556c19] se retiran los numeros imaginarios y complejos 4 files changed, 7 deletions(-) La implementación de numeros abundantes ya esta lista, por lo que vamos a unir las ramas main y numeros-3: git merge numeros-3 Se abrirá el editor de texto con la sifuiente entrada: Merge branch &#39;numeros-3&#39; # Por favor ingresa un mensaje de commit que explique por qué es necesaria esta fusión, # especialmente si esto fusiona un upstream actualizado en una rama de tópico. # # Líneas comenzando con &#39;#&#39; serán ignoradas, y un mensaje vacío aborta # el commit. Esta entrada la cambiaremos por la siguiente: implementacion de numeros abundantes en rama &#39;numeros-3&#39; # Por favor ingresa un mensaje de commit que explique por qué es necesaria esta fusión, # especialmente si esto fusiona un upstream actualizado en una rama de tópico. # # Líneas comenzando con &#39;#&#39; serán ignoradas, y un mensaje vacío aborta # el commit. Al guardad los cmbios obtendremos una salida así: Merge made by the &#39;ort&#39; strategy. caracteristicas-2.md | 1 + numeros-2.md | 1 + 2 files changed, 2 insertions(+) Revisamos los registros: git lg * bb296da - (hace 2 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] (HEAD -&gt; main) |\\ | * e26e013 - (hace 8 minutos) caracteristicas-2 modificado (numeros abundantes agregados) - [Nombre de usuario] (numeros-3) | * 5886d1b - (hace 10 minutos) numeros-2.md modificado (numeros abundantes agregados) - [Nombre de usuario] * | 9556c19 - (hace 3 minutos) se retiran los numeros imaginarios y complejos - [Nombre de usuario] |/ * 01e1562 - (hace 11 minuto) caracteristicas-2.md agregado - [Nombre de usuario] * 34238c5 - (hace 12 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 18 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 20 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 22 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 25 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 26 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 27 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 32 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 3 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 4 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 4 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 4 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 4 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 4 horas) README.md agregado - [Nombre de usuario] Vemos que se nosmuestra de uma manera muy visual la separación y unión de las ramas main y numeros-3. Por último, eliminamos la rama numeros-3 git branch -d numeros-3 Eliminada la rama numeros-3 (era e26e013). 5.3 Merge: Uniones con conflictos Esta vez vamos a generar un conflicto y al momendo de unir las ramas habrá que solucionarlo. Vamos a crear la rama numeros-4 siguiendo las indicaciones: Cambianso a la rama numeros-3 git checkout -b numeros-4 Cambiado a nueva rama &#39;numeros-4&#39; Vamos a editar el archivo problemas.md, e el que nos encontramos el siguiente contenido: # Problemas * Restar * Dividir * No abarca todos los números de la recta real * Sin cerradura en suma * Raíces de negativos Que cambiaremos por el siguiente contenido: # Problemas en los números * Restar * Dividir * No abarca todos los números de la recta real * Sin cerradura en suma * Raíces de negativos # Problemas en los números alternos * La factorización de grandes números en sus factores primos. * Se desconoce si existen infinitos números perfectos. * Encontrar todas las soluciones algebraicas de una ecuación polinómica dada. * Clasificar y encontrar patrones en los números abundantes. Hacemos el commit: git commit -am &quot;problemas.md modificado (numeros-2)&quot; [numeros-4 3447252] problemas.md modificado (numeros-2) 1 file changed, 9 insertions(+), 1 deletion(-) Cambiamos a la rama main para hacer modificaciones didtintas: git checkout main Cambiado a rama &#39;main&#39; Modificamos problemas.md dejando el siguiente contenido: # Problemas * Restar * Dividir * No abarca todos los números de la recta real * Sin cerradura en suma * Raíces de negativos * La factorización de grandes números en sus factores primos. * Se desconoce si existen infinitos números perfectos. * Encontrar todas las soluciones algebraicas de una ecuación polinómica dada. * Clasificar y encontrar patrones en los números abundantes. hacemos el registro: git commi -am &quot;problemas.md modificado&quot; [main 74aca37] problemas.md modificado 1 file changed, 5 insertions(+) Verificamos el estado del repositorio git lg * 74aca37 - (hace 28 segundos) problemas.md modificado - [Nombre de usuario] (HEAD -&gt; main) | * 3447252 - (hace 3 minutos) problemas.md modificado (numeros-2) - [Nombre de usuario] (numeros-4) |/ * bb296da - (hace 10 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] |\\ | * e26e013 - (hace 16 minutos) caracteristicas-2 modificado (numeros abundantes agregados) - [Nombre de usuario] (numeros-3) | * 5886d1b - (hace 18 minutos) numeros-2.md modificado (numeros abundantes agregados) - [Nombre de usuario] * | 9556c19 - (hace 11 minutos) se retiran los numeros imaginarios y complejos - [Nombre de usuario] |/ * 01e1562 - (hace 19 minuto) caracteristicas-2.md agregado - [Nombre de usuario] * 34238c5 - (hace 20 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 36 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 28 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 30 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 33 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 34 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 35 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 40 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 3 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 4 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 4 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 4 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 4 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 4 horas) README.md agregado - [Nombre de usuario] Ya hemos generado el conflicto, ahora veremos como es que Git nos informa sobre este y como solucionarlo Desde la rama main tratamos de hacer el merge: git merge numero-4 Auto-fusionando problemas.md CONFLICTO (contenido): Conflicto de fusión en problemas.md Fusión automática falló; arregle los conflictos y luego realice un commit con el resultado. Recibimos este mensaje de error por lo que debemos resolver el conflicto. entramos al archivo problemas.md pra editarlo, nos encontraremos el siguiente contenido: # Problemas en los números * Restar * Dividir * No abarca todos los números de la recta real * Sin cerradura en suma * Raíces de negativos &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= # Problemas en los números alternos &gt;&gt;&gt;&gt;&gt;&gt;&gt; numeros-4 * La factorización de grandes números en sus factores primos. * Se desconoce si existen infinitos números perfectos. * Encontrar todas las soluciones algebraicas de una ecuación polinómica dada. * Clasificar y encontrar patrones en los números abundantes. Aqui Git modificó el contenido del archivo problemas.md incorporando los cambios realizados desde ambas ramas, para arreglar el conflicto. Eliminamos primero las lineas que agregó Git para indicar el conflicto, de forma que nos queda algo así: # Problemas en los números * Restar * Dividir * No abarca todos los números de la recta real * Sin cerradura en suma * Raíces de negativos # Problemas en los números alternos * La factorización de grandes números en sus factores primos. * Se desconoce si existen infinitos números perfectos. * Encontrar todas las soluciones algebraicas de una ecuación polinómica dada. * Clasificar y encontrar patrones en los números abundantes. Seleccionamos el contenido con el que nos vamos a quedar y el resto lo descartamos, en este caso nos quedamos con el contenido que resultó del paso anterior, pero en otros casos hay seleccionar cambios realizados pr una o ambas ramas. Hacemos un commit de la unión git commit -am &quot;union de main con numero-4&quot; [main 5414405] union de main con numero-4 Verificamos el registro: git lg * 5414405 - (hace 33 segundos) union de main con numero-4 - [Nombre de usuario] (HEAD -&gt; main) |\\ | * 3447252 - (hace 4 minutos) problemas.md modificado (numeros-2) - [Nombre de usuario] (numeros-4) * | 74aca37 - (hace 7 minutos) problemas.md modificado - [Nombre de usuario] |/ * bb296da - (hace 12 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] |\\ | * e26e013 - (hace 18 minutos) caracteristicas-2 modificado (numeros abundantes agregados) - [Nombre de usuario] | * 5886d1b - (hace 20 minutos) numeros-2.md modificado (numeros abundantes agregados) - [Nombre de usuario] * | 9556c19 - (hace 13 minutos) se retiran los numeros imaginarios y complejos - [Nombre de usuario] |/ * 01e1562 - (hace 21 minuto) caracteristicas-2.md agregado - [Nombre de usuario] * 34238c5 - (hace 22 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 28 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 30 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 32 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 35 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 36 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 37 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 42 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 4 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 5 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 5 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 5 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 5 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 5 horas) README.md agregado - [Nombre de usuario] Por último, eliminamos la rama numeros-4 git branch -d numeros-4 Eliminada la rama numeros-4 (era 3447252). "],["tags-etiquetas.html", "Capítulo 6 Tags (Etiquetas) 6.1 Creando primeros Tags", " Capítulo 6 Tags (Etiquetas) En esta sección veremos que son los tags, cual es su función / utilidad y como empearlas dentro de nuestro repositorio. Tags: Los tags en Git son referencias que apuntan a commits específicos, utilizados para marcar puntos importantes en la historia del proyecto, como versiones de lanzamiento. 6.1 Creando primeros Tags La creación de Tags es realmente sencilla, para crear un Tag o etiqueta en el commit actual, basta con usar el siguiente comando: git tag [nombre de la etiqueta] Por ejemplo, supongamos que el proyecto numeros se encuentra en el punto en que puede salir a produccion y el último commit está listo para sel la primera versión de producción, por lo que debemos darle una etiqueta que nos indique el pundo correspondiente a la salida a producción: git tag primera-version Una vez creada la etiqueta, podemos encontrarla al ver los registros del repositorio: git lg * 5414405 - (hace 5 minutos) union de main con numero-4 - [Nombre de usuario] (HEAD -&gt; main, tag: primera-version) |\\ | * 3447252 - (hace 9 minutos) problemas.md modificado (numeros-2) - [Nombre de usuario] (numeros-4) * | 74aca37 - (hace 12 minutos) problemas.md modificado - [Nombre de usuario] |/ * bb296da - (hace 17 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] Podemos listar las etiquetas que tenemos con: git tag primera-version Es aconsejable tener un orden en nuestras etiquetas para mejorar la administracion de las mismas. Para eliminar la unaeqiqueta, en este caso la única que hemos creado: git tag -d primera-version Etiqueta primera-version eliminada (era 5414405) Una forma de llamar a las etiquetas muy común y bastante útil, llamado versionamiento semantico, a la hora de identificarlas es utilizar una sintaxis de versiones, como por ejemplo: git tag -a v-1.0.0 -m &quot;Version 1.0.0 lista&quot; En este caso el parámetro -a indica que la etiqueta es anorada, lo que significa que almacena más informacion como el nombre del creador, la fecha de creación y un mensaje, opcional, que se agrega con el parámetro -m seguido del mensaje que deseamos guardar. Si deseamos crear etiquetas en puntos de registro distintos a donde nos encontramos, simplemente hay que utilizar el hash de registro del commit que deseamos etiquetar, por ejemplo, supongamos que quuiero etiquetar como v-0.1.0 al punto en el que se eliminó `restriccion-division.md``. Primero listamos los registros git lg * 5414405 - (hace 33 segundos) union de main con numero-4 - [Nombre de usuario] (HEAD -&gt; main, tag: v-1.0.0) |\\ | * 3447252 - (hace 4 minutos) problemas.md modificado (numeros-2) - [Nombre de usuario] (numeros-4) * | 74aca37 - (hace 7 minutos) problemas.md modificado - [Nombre de usuario] |/ * bb296da - (hace 12 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] |\\ | * e26e013 - (hace 18 minutos) caracteristicas-2 modificado (numeros abundantes agregados) - [Nombre de usuario] | * 5886d1b - (hace 20 minutos) numeros-2.md modificado (numeros abundantes agregados) - [Nombre de usuario] * | 9556c19 - (hace 13 minutos) se retiran los numeros imaginarios y complejos - [Nombre de usuario] |/ * 01e1562 - (hace 21 minuto) caracteristicas-2.md agregado - [Nombre de usuario] * 34238c5 - (hace 22 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 28 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 30 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 32 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 35 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 36 minutos) restriccion-division.md eliminado - [Nombre de usuario] * f67c77c - (hace 37 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 42 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 4 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 5 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 5 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 5 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 5 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 5 horas) README.md agregado - [Nombre de usuario] Luego identificamos el hash de registro, en este caso es 8606014 y lo colocamos al final del comando que crea la etiqueta: git tag -a v-0.1.0 -m &quot;Version 0.1.0: alpha&quot; [hash] Ahora encontraremos la etiqueta al ver los registros del repositorio: git lg * 5414405 - (hace 33 segundos) union de main con numero-4 - [Nombre de usuario] (HEAD -&gt; main, tag: v-1.0.0) |\\ | * 3447252 - (hace 4 minutos) problemas.md modificado (numeros-2) - [Nombre de usuario] (numeros-4) * | 74aca37 - (hace 7 minutos) problemas.md modificado - [Nombre de usuario] |/ * bb296da - (hace 12 minutos) implementacion de numeros abundantes en rama &#39;numeros-3&#39; - [Nombre de usuario] |\\ | * e26e013 - (hace 18 minutos) caracteristicas-2 modificado (numeros abundantes agregados) - [Nombre de usuario] | * 5886d1b - (hace 20 minutos) numeros-2.md modificado (numeros abundantes agregados) - [Nombre de usuario] * | 9556c19 - (hace 13 minutos) se retiran los numeros imaginarios y complejos - [Nombre de usuario] |/ * 01e1562 - (hace 21 minuto) caracteristicas-2.md agregado - [Nombre de usuario] * 34238c5 - (hace 22 minutos) numeros-2.md agregado - [Nombre de usuario] * 62b4657 - (hace 28 minutos) .gitignore actualizado (extension .log) - [Nombre de usuario] * ae676b5 - (hace 30 minutos) .gitignore agregado - [Nombre de usuario] * c32cdc0 - (hace 32 minutos) producto.md eliminado - [Nombre de usuario] * 8d867e7 - (hace 35 minutos) suma.md renombrado~ - [Nombre de usuario] * 8606014 - (hace 36 minutos) restriccion-division.md eliminado - [Nombre de usuario] (tag: v-0.1.0) * f67c77c - (hace 37 minutos) division-cero.md renombrado - [Nombre de usuario] * 3741b68 - (hace 42 minutos) division-cero.md agregado - [Nombre de usuario] * 451e900 - (hace 4 horas) numeros imaginarios y complejos agregados - [Nombre de usuario] * f0e5d47 - (hace 5 horas) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] * d610af4 - (hace 5 horas) problemas.md agregado - [Nombre de usuario] * a54e313 - (hace 5 horas) caracteristicas.md agregado - [Nombre de usuario] * 37d5a5b - (hace 5 horas) numeros.md agregado - [Nombre de usuario] * a4356d4 - (hace 5 horas) README.md agregado - [Nombre de usuario] Al listar las etiquetas que tenemos: git tag v-0.1.0 v-1.0.0 Si queremos más información sobre alguna de las etiquetas, podemos emplear: git show [tag] tag v-0.1.0 Tagger: [nombre de usuario] &lt;[Direccion de correo]&gt; Date: Sat Aug 3 23:14:33 2024 -0600 Version 0.1.0: alpha commit 8606014249972136e73e4d02e258c1c847b13740 (tag: v-0.1.0) Author: [nombre de usuario] &lt;[Direccion de correo]&gt; Date: Sun Jul 21 20:38:09 2024 -0600 restriccion-division.md eliminado diff --git a/restriccion-division.md b/restriccion-division.md deleted file mode 100644 index a0c00a9..0000000 --- a/restriccion-division.md +++ /dev/null @@ -1,2 +0,0 @@ -# Esta es la implementacion de: -Division entre cero Aquí encontramos más información como autor, fecha, información del commit al que apunta y el mensaje con el que se guardó. "],["git-stash.html", "Capítulo 7 Git Stash", " Capítulo 7 Git Stash En este capítulo, conoceremos y emplearemos el Stash, una funcion para rastrear cambios sin alterar los registros del repositorio, es decir, sin la necesidad de un commit. Stash: El Stash en Git es una funcionalidad que guarda temporalmente cambios no confirmados en el área de trabajo para permitir trabajar en otra cosa sin perder el progreso actual. Podemos considerar al Stash como una bóveda en la que guardamos los cambios realizados desde el último commit, o en el que se encuentre el HEAD, para no perderlos en caso de que se requiera trabajar en otra ubicación del repositorio, o en otro commit, esto sin la necesidad de hacer una confirmación de esos cambios. De manera que podamos recuperar ese trabajo no confirmado para continuar el trabajo donde hbía quedado. Es importante no abusar del Stash ya que, aunque se puede etiquetar la informacion almacenada allí, es muy fácil olvidar que cambios le corresponden a cada ubicación sobre la que se está trabajando. Lo más recomendable es apoyarse en el uso de las ramas y, en caso de requerir el uso del Stash, recuperar esos cambios almacenados lo antes posible y continuar con el trabajo donde se dejó, en lugar de mantenerlo pendiente. "],["estructura-curso.html", "Capítulo 8 Estructura Curso", " Capítulo 8 Estructura Curso Section 1: Inicio del curso Objetivos del curso Funcionamiento del curso Dudas y consultas Instalaciones necesarias para el curso section 2: Fundamentos Introducción a los fundamentos de git Importancia de git como sistema de control de versiones Primeros comandos de git Nuestro primer repositorio Nota - CRLF ¿Qué hace git por nosotros en estos momentos? Repaso de comandos vistos Cambiar nombre de la rama “master” a “main” Demostración de la creación, puesta en escena y commits Bonus VSCode add y commits Diferentes formas de agregar archivos al escenario Creando Alias para nuestros comandos Examen teórico #1 Section 3: Un poco más allá de los fundamentos de git Introducción a la sección Cambios en los archivos Actualizar mensaje del commit y revertir commits Preparando repositorio para viajes en el tiempo Viajes en el tiempo, resets y reflog Cambiar el nombre y eliminar archivos mediante y fuera de git Ignorando archivos que no deseamos Tarea práctica #1 Section 4: Ramas, uniones, conflictos y tags Introducción a la sección Introducción Ramas, uniones y conflictos Merge: Fast-Forward Merge: Unión automática Merge: Uniones con conflictos Tags - Etiquetas Creando etiquetas - Tags Examen teórico #2 Section 5: Git Stash y Git Rebase - Para realizar cambios de emergencia Introducción a la sección Introducción al Stash Git Stash Conflictos con el Stash Stash avanzado Introducción al Git Rebase Rebase: Actualizando una rama Rebase: Squash Rebase: Reword Rebase: edit Examen teórico #3 Section 6: Inicios en GitHub Remote, Git Remote, Push &amp; Pull Introducción a la sección Documentaciones útiles Creando una cuenta en GitHub Push a GitHub Push de los Tags de nuestro repositorio Creando - release tags Actualizar el perfil de GitHub Pull de los últimos cambios en el repositorio de GitHub Warning: Pulling without reconcile strategy Clonar un repositorio Subir cambios locales al remoto Git Pull Rebase Ejercicio: Git pull Section 7: GitHub básico Introducción a la sección Introducción a GitHub Introducción a la interfaz de GitHub Markdown y GitHub Markdown Documentación sobre el Markdown de GitHub Buscando archivos en GitHub Git Fetch Comentarios en los commits Comprender el flujo de GitHub Bonus: No hacer esto Section 8: GitHub - avanzado Introducción a la sección Fork, Clone y Colaboraciones Cloning y Fork Pull Request Actualizando nuestro Fork Introducción a los flujos de trabajo Feature Branch - Flujo de trabajo mediante pull request Bonus: Actualizar un Alias Feature Branch - Revisando el trabajo de otros compañeros Limpiar ramas que ya no son necesarias Rama de producción: GitHub Recuperar una rama de producción Section 9: GitHub Issues, MileStones y Colaboradores Introducción a la sección GitHub Issues Cerrar un Issue Cerrar un Issue mediante un commit Issue Templates Labels - Etiquetas MileStones: Un punto importante Agregando colaboradores a un repositorio Section 10: Wikis, Proyectos y GitHub Pages Introducción a la sección Nota de actualización: Wikis Wiki Agregando referencias entre páginas en la Wiki Proyectos de GitHub GitHub Pages - Para tu usuario u Organización GitHub Pages - Para tu proyecto o repositorio Insights Section 11: Organizaciones y Equipos Introducción a la sección Creando una organización Teams: Equipos de trabajo Repositorios y privilegios a los equipos de nuestra organización Más información sobre los miembros de la organización Section 12: Gist Introducción a la sección Creando un Gist Usando Plugins de Gist con tokens personales Otros detalles de los Gist "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
