# Los cambios en Git

## Cambios en los archivos

Cuando acabas de editar un archivo y quieres ver con claridad las diferencias entre las "versiones", puedes hacerlo de varias formas, como hacer copia del "original" o ir revirtiendo los cambios poco a poco, pero tener toda la información disponible hace que fácilmente se pierda de vista lo que uno busca;
git puede mostrarte, de manera organizada, unicamente los cambios que hay entre las dos versiones que quieres comparar de un archivo, lo que facilita bastante distinguir los cambios efectuados.

En esta ocación presentaremos un comando que nos ayudará a distinguir los cambios realizados en un archivo.

```{bash eval=F}
git diff
```

```{bash eval=F}
diff --git a/instalaciones.md b/instalaciones.md
index a7cc8e4..512d0e8 100644
--- a/instalaciones.md
+++ b/instalaciones.md
@@ -1,8 +1,14 @@
 # Pasos para instalar
-Seguir estos pasos:
+1. Seguir estos pasos:
 
 ```
-npm install
+yarn install
 ```
 
+2. Ejecutar el comando :
+```
+npm start
+```
+
+
 

```


Muestra las diferencias no confirmadas entre el directorio de trabajo y el último commit realizado. En la salida podemos notar que hay líneas que comienzan con `+` y `-`, estos cimbolos nos indican los cambios que presenta el archivo en el que se está trabajando respecto al último registro realizado.  
`+[contenido]` Indica que se agregó `[contenido]` al archivo en cuestión, mientras que 
`-[contenido]` Indica que `[contenido]` fue removido delarchivo, preo solo muestra cambios en archivos que ya tienen seguimiento y no reconoce los cambios que se encuentran en el stage. Las líneas que no cuentan con estos marcadores no han sido modificadas.

```{bash eval=F}
git diff --staged
```

```{bash eval=F}
diff --git a/instalaciones.md b/instalaciones.md
index a7cc8e4..512d0e8 100644
--- a/instalaciones.md
+++ b/instalaciones.md
@@ -1,8 +1,14 @@
 # Pasos para instalar
-Seguir estos pasos:
+1. Seguir estos pasos:
 
 ```
-npm install
+yarn install
 ```
 
+2. Ejecutar el comando :
+```
+npm start
+```
+
+
 


```


Muestra las diferencias presentes en los elementos que se encuentran en el área de preparación de la misma manera que `git diff`.

## Correción de commits

En ocaciones, por algún descuido, hacemos un commit con un mensaje incompleto, mal escrito o simplemente distinto a lo que buscamos presentar, pero no hay de que alarmarse, este mensaje se puede corregir de manera sencilla.

```{bash eval=F}
git commit --amend -m "[correccion]"
```

```{bash eval =F}
[main 9d520f3] [correccion]
 Date: Thu Jul 11 18:21:25 2024 -0600
 1 file changed, 5 insertions(+)
```

Este comando permite cambiar el mensaje del **último commit** registrado por `[correccion]`.

Tambien ocurre que hicimos una confirmación que puede considererse incompleta, aunque sencillamente podrías hacer otro commit con los cambios restantes, Git ofrece la opción de restaurar el commit deseado para continuar trabajando sobre él.

```{bash eval=F}
git reset --soft HEAD^
```

Deshace el último commit, manteniendo los cambios en el área de preparación.
Puedes sustituir `HEAD^` por el hash correspondiente al último commit, incliso puedes hacerlo con cualquier otro commit, pero es más simple dejarlo así.

## Preparación de repositorio

Vamos a trabajar ahora con la carpeta `material'numeros`, que se les proporcionará, y pondremos en practica los conocimientos adquiridos hasta ahora, para ello seguiremos las siguientes instrucciones:

1. desde la terminal, nos colocamos en la ubicación de la carpeta e inicializa un repositorio de Git con

```{bash eval=F}
git init
```

2. Uno por uno, ve registrando los archivos: `README.md`, `numeros.md`, `caracteristicas.md`, `problemas.md` y el directorio `operaciones`; recuerde que debes llevarlos al Satage con 

```{bash eval=F}
git add [elemento]
```

para luego poder registrarlos con un mensaje a traves de

```{bash eval=F}
git commit -m "[elemento] agregado"
```

3. Vamos a cambiar el mensaje de registro que hicimos al guardad el directorio `operaciones`, para ello usaremos

```{bash eval=F}
git commit --amend
```
```{bash eval=F}
operaciones/ agregado

# Por favor ingresa el mensaje del commit para tus cambios. Las
#  líneas que comiencen con '#' serán ignoradas, y un mensaje
#  vacío aborta el commit.
#
# Fecha:     Sat Jul 20 14:20:37 2024 -0600
#
# En la rama main
# Cambios a ser confirmados:
#	nuevos archivos: operaciones/producto.md
#	nuevos archivos: operaciones/suma.md
#
```


Este comando abrirá el editor de texto por defecto de cada equipo para mostrar un archivo de registro, el cual vamos a editar de la siguiente manera:
La primera línea, donde se encuentra escrito `operacione/ agregado`, cambiaremos ese mensaje por `operaciones/suma.md y operaciones/producto.md agregados` y guardemos los cambios en el archivo de registro.

Con los registros realizados hasta ahora, tomando en cuenta que se suguió la recomendación de `alias` presentada anteriormente, usando `git lg` deberiamos tener una salida como la que sigue

```{bash eval=F}
git lg
```
```{bash eval=F}
* f71dc81 - (hace 9 segundos) operaciones/suma.md y operaciones/producto.md agregados - [Nombre de usuario] (HEAD -> main)
* 1770555 - (hace 55 segundos) problemas.md agregado - [Nombre de usuario]
* 72001b5 - (hace 2 minutos) caracteristicas.md agregado - [Nombre de usuario]
* 8a76d72 - (hace 2 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 3 minutos) README.md agregado - [Nombre de usuario]
```

## Viajes en los registros 


1. Empezando con la edición de archivos, en el archivo `numeros.md` se encontrarán con una lista de clases de números, a la que le agregaremos, al final, el siguiente elemento:

```{bash eval=F}
* Imaginarios
```

Luego, al archivo `caracteristicas.md` le vamos a agregar:

```{bash eval=F}
* Unidad imaginaria "i".
```

Después, en el archivo `problemas.md` añadimos:

```{bash eval=F}
* Sin cerradura en producto
```

Tras los cambios anteriormente realizados, haremos una verificación.

```{bash eval=F}
git s
```
```{bash eval=F}
## main
 M caracteristicas.md
 M numeros.md
 M problemas.md
```


Ahora haremos un nuevo commit con el siguiente comando.

```{bash eval=F}
git commit -am "numeros imaginarios agregados"
```

2. Comenzaremos con los viajes en el tiempo, primero veamos nuestra línea del tiempo con

```{bash eval=F}
git lg
```
```{bash eval=F}
* c8b5864 - (hace 3 minutos) numeros imaginarios agregados - [Nombre de usuario] (HEAD -> main)
* f71dc81 - (hace 8 minutos) operaciones/ agregado - [Nombre de usuario]
* 1770555 - (hace 9 minutos) problemas.md agregado - [Nombre de usuario]
* 72001b5 - (hace 10 minutos) caracteristicas.md agregado - [Nombre de usuario]
* 8a76d72 - (hace 10 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 11 minutos) README.md agregado - [Nombre de usuario]

```
Vemos todos los registros que hemos hecho hasta ahora, pero notemos que al agregar loe números imaginarios ya podemos hablar de los números complejos, por lo que quermeos agregarlos tambíen, pero en lugar de hacer un nuevo commit, queremos que se agreguen a la vez. Para ello, vamos a usar de nuevo el comando `git reset --soft`, pero recordemos que este nos permite darle la entrade `HEAD^` o en su lugar el `hash` con el que git tiene registrado el commit al que buscamos volver; esta vez usaremos la segunda forma, por lo que emplearemos

```{bash eval=F}
git reset --soft [hash]
```

Ahora podemos agregar los números complejos para registrarlos junto a los imaginarios, lo que haremos como anteriormente:

Al archivo `numerso.md` le agregaremos:

```{bash eval=F}
* Complejos
```

Luego, al archivo `caracteristicas.md` le vamos a agregar:

```{bash eval=F}
* Unión de reales e imaginarios, plano complejo.
```

Después, en el archivo `problemas.md` añadimos:

```{bash eval=F}
* --------------------------------------------
```

Por último, tanto a `suma.md` como a `producto.md`, ubicados en el directorio `operaciones`, agregaremos el elemento:

```{bash eval=F}
* Complejos
```

Haciendo una verificación de los cambios.

```{bash eval=F}
git s
```
```{bash eval=F}
## main
MM caracteristicas.md
MM numeros.md
 M operaciones/producto.md
 M operaciones/suma.md
MM problemas.md
```
Veremos que hay algunos cambios que ya se agregaron al Satge, los referentes a la entrada de números imaginarios, preo también encontramos cambios en el directorio de trabajo, los que se acaban de añadir.


Ahora haremos un nuevo commit con el siguiente comando.

```{bash eval=F}
git commit -am "numeros imaginarios y complejos agregados"
```
Con esto hemos cambiado el registro que teníamos por uno más completo.

Veamos como se reflejan estos cambios en los registros:

```{bash eval=F}
git lg
```

```{bash eval=F}
* 76ae643 - (hace 5 segundos) numeros imaginarios y complejos agregados - [Nombre de usuario] (HEAD -> main)
* f71dc81 - (hace 8 minutos) operaciones/ agregado - [Nombre de usuario]
* 1770555 - (hace 9 minutos) problemas.md agregado - [Nombre de usuario]
* 72001b5 - (hace 10 minutos) caracteristicas.md agregado - [Nombre de usuario]
* 8a76d72 - (hace 10 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 11 minutos) README.md agregado - [Nombre de usuario]
```

3. Ahora, percibimos que algo anda mal en el proyecto y notamos que el último punto en el que todo marchaba bien es tras haber agregado `problemas.md` por lo que vamos a copiar su `hash` de registro y esta vez usaremos:

```{bash eval=F}
git reset --mixed [hash]
```
```{bash eval=F}
Cambios fuera del área de stage tras el reset:
M	caracteristicas.md
M	numeros.md
M	problemas.md
```

Lo que nos regresará al punto que marcamos pero esta vez con los cambios realizados fuera del Stage, así mantenemos los cambios en  el directorio de trabajo. Aquí podemos ver el el estado del repositorio.

```{bash eval=F}
git s
```
```{bash eval=F}
## main
 M caracteristicas.md
 M numeros.md
 M problemas.md
?? operaciones/
```

También veamos como quedan los registros del repositorio.

```{bash eval=F}
git lg
```
```{bash eval=F}
* 1770555 - (hace 15 minutos) problemas.md agregado - [Nombre de usuario]
* 72001b5 - (hace 16 minutos) caracteristicas.md agregado - [Nombre de usuario]
* 8a76d72 - (hace 16 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 17 minutos) README.md agregado - [Nombre de usuario]
```

Como los cambios realizados adelande de donde estamos realmente no no van a servir, vamos a usar `reset`, al mismo `hash` de la vez anterior, pero de una manera distinta.

```{bash eval=F}
git resset --hard [hash]
```
Esta vez el repositorio queda tal cual como Git lo registró y los cambios realizados tras este commit han sido removidos.

Continuamos regresando en el tiempo a los commits donde se agregaron `caracteristicas.md` y una vez más a donde añadimos `numeros.md`

Llegados a este punto resulta que no había nada malo en el proyecto y hay que volver al punto en el que estábamos originalmente para recuperar toda nustra línea del tiempo, puede parecer imposible ya que eliminamos los registros que ya teníamos y tendremos que hacer cada cambio de nuevo pero Git mantiene un historial con los cambios hechos en los propios registros lo que permite recuperar esa información que se podría considerar perdida. 

Notemos que al acceder al historial de commits no podemos ver mas allá del segundo.

```{bash eval=F}
git lg
```
```{bash eval=F}
* 8a76d72 - (hace 20 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 21 minutos) README.md agregado - [Nombre de usuario]
```

Pero Git tiene otro comando para acceder a los registros, uno que rastrea cambios de los propios registros y los movimientos en ellos.

```{bash eval=F}
git reflog
```
```{bash eval=F}
* 1770555 - (hace 15 minutos) problemas.md agregado - [Nombre de usuario]
* 72001b5 - (hace 16 minutos) caracteristicas.md agregado - [Nombre de usuario]
* 8a76d72 - (hace 16 minutos) numeros.md agregado - [Nombre de usuario]
* e4a806d - (hace 17 minutos) README.md agregado - [Nombre de usuario]
```





